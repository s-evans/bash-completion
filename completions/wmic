#!/usr/bin/env sh

# NOTE: invoke _wmic_init_cache to populate the cache and speed up retrieval of completion candidates

_wmic_init_cache_internal()
{
    local current_alias current_verb

    _wmic_base_switches
    _wmic_aliases

    for current_alias in $_wmic_aliases_cache ; do
        _wmic_alias_verbs "$current_alias"
        _wmic_alias_list_formats "$current_alias"
        _wmic_alias_methods "$current_alias"

        for current_verb in $_wmic_alias_verbs_cache["$current_alias"] ; do
            _wmic_alias_verb_init "$current_alias" "$current_verb"
        done
    done
}

_wmic_init_cache()
{
    declare -g -A _wmic_alias_verb_switches_cache _wmic_alias_verb_properties_cache _wmic_alias_verbs_cache _wmic_alias_list_formats_cache _wmic_alias_methods_cache
    _wmic_init_cache_internal > /dev/null
}

_wmic_base_switches()
{
    if [[ "$_wmic_base_switches_cache" ]]; then
        echo $_wmic_base_switches_cache
        return
    fi

    _wmic_base_switches_cache=$(wmic /? | sed '/^\//!d; s/[ \[].*//; s/./\l&/g')
    echo $_wmic_base_switches_cache
}

_wmic_aliases()
{
    if [[ "$_wmic_aliases_cache" ]]; then
        echo $_wmic_aliases_cache
        return
    fi

    _wmic_aliases_cache=$(wmic /? | sed '1,/:/d; 1,/:/d; 1,/:/d; 1,/:/d; s/\r//g; /^$/,$d; s/ .*//; s/./\l&/g')
    echo $_wmic_aliases_cache
}

_wmic_alias_verbs()
{
    if [[ "${_wmic_alias_verbs_cache["$1"]}" ]]; then
        echo ${_wmic_alias_verbs_cache["$1"]}
        return
    fi

    _wmic_alias_verbs_cache["$1"]=$(wmic $1 /? | sed '1,/:/d; 1,/:/d; s/\r//g; /^$/d; s/^[^ ]* //; s/ .*//; s/./\l&/g')
    echo ${_wmic_alias_verbs_cache["$1"]}
}

_wmic_alias_verb_init()
{
    local subscript="$1_$2"

    if [[ "${_wmic_alias_verb_switches_cache["$subscript"]}" ]]; then
        return
    fi

    local output=$(wmic $1 $2 /?)
    local IFS=$'\n'

    _wmic_alias_verb_switches_cache["$subscript"]=$(printf '%s\n' $output | sed '/^\//!d; s/[(< \[].*//; s/./\l&/g; s/[:=]/\\&/g')
    _wmic_alias_verb_properties_cache["$subscript"]=$(printf '%s\n' $output | sed '1,/^=/d; s/\r//g; /^$/,$d; s/ .*//; s/./\l&/g')
}

_wmic_alias_verb_switches()
{
    local subscript="$1_$2"
    if [[ "${_wmic_alias_verb_switches_cache["$subscript"]}" ]]; then
        echo ${_wmic_alias_verb_switches_cache["$subscript"]}
        return
    fi

    _wmic_alias_verb_switches_cache["$subscript"]=$(wmic $1 $2 /? | sed '/^\//!d; s/[(< \[].*//; s/./\l&/g; s/[:=]/\\&/g')
    echo ${_wmic_alias_verb_switches_cache["$subscript"]}
}

_wmic_alias_verb_properties()
{
    local subscript="$1_$2"
    if [[ "${_wmic_alias_verb_properties_cache["$subscript"]}" ]]; then
        echo ${_wmic_alias_verb_properties_cache["$subscript"]}
        return
    fi

    _wmic_alias_verb_properties_cache["$subscript"]=$(wmic $1 $2 /? | sed '1,/^=/d; s/\r//g; /^$/,$d; s/ .*//; s/./\l&/g')
    echo ${_wmic_alias_verb_properties_cache["$subscript"]}
}

_wmic_alias_list_formats()
{
    if [[ "${_wmic_alias_list_formats_cache["$1"]}" ]]; then
        echo ${_wmic_alias_list_formats_cache["$1"]}
        return
    fi

    _wmic_alias_list_formats_cache["$1"]=$(wmic $1 list /? | sed '/ - /!d; /^\//d; s/ .*//; s/./\l&/g')
    echo ${_wmic_alias_list_formats_cache["$1"]}
}

_wmic_alias_methods()
{
    if [[ "${_wmic_alias_methods_cache["$1"]}" ]]; then
        echo ${_wmic_alias_methods_cache["$1"]}
        return
    fi

    _wmic_alias_methods_cache["$1"]=$(wmic $1 call /? | sed '1,/^=/d; s/\W.*//; /^$/d; s/./\l&/g')
    echo ${_wmic_alias_methods_cache["$1"]}
}

_wmic_users()
{
    local options IFS
    IFS=$'\n'
    options=$(wmic useraccount get name | sed -e '1d' -e 's/\r//' -e 's/ \+$//' -e '/\$$/ d' -e '/^$/ d')
    printf '%q\n' ${options,,} | sed -e 's/[:=]/\\&/g' -e "/''/d"
}

_wmic()
{
    local cur prev words cword options IFS aliases current_alias current_verb cmds switches properties verbs temp_verb_position
    declare -i verb_position alias_position
    _init_completion

    if [[ "$prev" == '/\?'* ]]; then
        return
    fi

    cur=$(printf '%q' "${cur,,}")
    aliases=( $(_wmic_aliases) )
    alias_position=$(printf '%s\n' ${words[@]::cword} | (command grep -m 1 -h -Fxnf <(printf '%s\n' ${aliases[@]}) || echo 0) | sed 's/:.*//')

    if [[ $alias_position -ne 0 ]]; then
        alias_position=alias_position-1
        current_alias=${words[alias_position]}

        # generally, the verb comes immediately after the alias
        verb_position=alias_position+1
        current_verb=${words[verb_position]}

        # if there is a where clause, wait until the user is finished with it, then get the verb that follows
        if [[ "$current_verb" == where && $cword-1 -gt $verb_position ]]; then
            verb_position=verb_position+2
            current_verb=${words[verb_position]}
        fi

    fi

    if [[ -z "$current_alias" ]]; then
        case ${words[cword]} in

            # TODO: more completion possible here?
            /authority\\:*|/password\\:*|/record\\:*|/locale\\:*|/node\\:*|/role\\:*|/namespace\\:*)
                return
                ;;

            /user\\:*)
                IFS=$'\n'
                options=$(_wmic_users | sed -e 's/.*/\/user\\:&/')
                ;;

            /implevel\\:*)
                options='/implevel\:anonymous /implevel\:identify
                /implevel\:impersonate /implevel\:delegate'
                ;;

            /authlevel\\:*)
                options='/authlevel\:default /authlevel\:none
                /authlevel\:connect /authlevel\:call /authlevel\:pkt
                /authlevel\:pktintegrity /authlevel\:pktprivacy'
                ;;

            /privileges\\:*)
                options='/priveleges\:enable /priveleges\:disable'
                ;;

            /aggregate\\:*)
                options='/aggregate\:on /aggregate\:off'
                ;;

            /failfast\\:*)
                options='/failfast\:on /failfast\:off'
                ;;

            /interactive\\:*)
                options='/interactive\:on /interactive\:off'
                ;;

            /trace\\:*)
                options='/trace\:on /trace\:off'
                ;;

            /output\\:*)
                # TODO: filename completion
                options='/output\:stdout /output\:clipboard'
                ;;

            /append\\:*)
                # TODO: filename completion
                options='/append\:stdout /append\:clipboard'
                ;;

            *)
                cmds=( ${words[@]::cword} )
                switches=( $(_wmic_base_switches) )
                options=$(_complement cmds[@] switches[@])
                ;;

        esac

        options+=" ${aliases[*]} /?\\:brief /?\\:full "

    elif [[ $cword -eq $verb_position ]]; then
        options=$(_wmic_alias_verbs $current_alias)
        options+=' where'

    elif [[ $current_verb == where ]]; then
        # TODO: support parenthseses

        # get the where clause as a single argument
        local real_cur="${COMP_WORDS[COMP_CWORD]}"

        # drop cword and following args
        COMP_WORDS=( "${COMP_WORDS[@]::COMP_CWORD}" )

        # split the where clause on spaces and add each token to the array
        COMP_WORDS+=( $(printf '%s\n' $(printf '%s' "$real_cur" "0" | sed 's/\\ / /g')) )

        # update the arg count
        COMP_CWORD=${#COMP_WORDS[@]}-1

        # drop the excess trailing character that was used to get an accurate arg count
        COMP_WORDS[COMP_CWORD]=$(printf %s "${COMP_WORDS[COMP_CWORD]}" | sed 's/.$//')

        # figure out where we are in the where clause
        declare -i count=$COMP_CWORD-$alias_position-2
        declare -i mod=$count%4

        # figure out where the where clause is in the arg list
        declare -i clause_position=$verb_position+1
        declare -i clause_length=$COMP_CWORD-$clause_position

        # get the where clause
        local clause=( ${COMP_WORDS[@]:clause_position:clause_length} )

        # create the prefix
        if [[ ${#clause[@]} -ne 0 ]]; then
            local prefix="$(printf '%s\ ' ${clause[@]})"
        fi

        # determine options
        if [[ $mod -eq 0 ]]; then # properties
            options=$(_wmic_alias_verb_properties $current_alias get)

        elif [[ $mod -eq 1 ]]; then # comparison opertors
            options='\= \!\= like \< \<\= \> \>\='

        elif [[ $mod -eq 2 ]]; then # values
            # TODO: complete values from a query
            # TODO: generally these are enclosed in escaped single quotes
            options=''

        elif [[ $mod -eq 3 ]]; then # boolean logic
            options='and or not'

        fi

        # prefix options with the existing clause
        options=$(printf "${prefix}%s\ \n" $options)

        # update cur
        cur="${prefix}${COMP_WORDS[COMP_CWORD]}"

        # do completion
        IFS=$'\n'
        compopt -o nospace
        COMPREPLY=( $( compgen -W '$options' -- "$(printf '%q' $cur)" ) )
        return

    else
        cmds=( ${words[@]:verb_position+1:cword} )
        local has_switch=$(printf '%s\n' ${cmds[@]} | sed '/^\//!d')

        switches=( $(_wmic_alias_verb_switches $current_alias $current_verb) )
        options=$(_complement cmds[@] switches[@])

        # TODO: completion for switch values

        if [[ -z "$has_switch" ]]; then
            case $current_verb in

                call)
                    # TODO: complete method arguments
                    if [[ $cword -eq $verb_position+1 ]]; then
                        options+=' '$(_wmic_alias_methods $current_alias)
                    fi
                    ;;

                list)
                    if [[ $cword -eq $verb_position+1 ]]; then
                        options+=' '$(_wmic_alias_list_formats $current_alias)
                    fi
                    ;;

                get)
                    properties=( $(printf '%s, ' $(_wmic_alias_verb_properties $current_alias $current_verb)) )
                    options+=' '$(_complement cmds[@] properties[@])
                    ;;

                set)
                    # TODO: complete assignment operator and skip values?
                    # TODO: comma separate properties list?
                    options+=' '$(_wmic_alias_verb_properties $current_alias $current_verb)
                    ;;

                create)
                    # TODO: complete assignment operator and skip values?
                    # TODO: comma separate properties list?
                    options+=' '$(_wmic_alias_verb_properties $current_alias $current_verb)
                    ;;

                *)
                    ;;

            esac
        fi
    fi

    COMPREPLY=( $( compgen -W '$options' -- $cur ) )
    [[ $COMPREPLY == /*: ]] && compopt -o nospace
}

complete -o default -F _wmic wmic wmic.exe WMIC WMIC.exe

