#!/usr/bin/env sh

# TODO: make registry path handling more robust (ie. hkcu\software<tab>)

_reg_keys()
{
    local IFS options
    IFS=$'\n'
    options=$(_windows_reg_keys $key)
    COMPREPLY=( $(compgen -W '$options' -- $(printf %q $cur) ) )
    [[ $COMPREPLY == *\\ ]] && compopt -o nospace
}

_reg_values()
{
    local IFS options
    IFS=$'\n'
    options=$(_windows_reg_values $key)
    COMPREPLY=( $(compgen -W '$options' -- $(printf %q $cur) ) )
}

_windows_reg_keys()
{
    local tmp options IFS

    # process the string so that the reg utility will understand it
    tmp=$(echo "$1" | sed -e 's/\\[^\]*$//')

    # query for additional keys
    options=$(reg query "$tmp" /f "*" /k 2> /dev/null | sed -e '1d' -e '$d' -e 's/$/\\/')

    # escape bash tokenizer strings and separate with newlines
    IFS=$'\n'
    options=$(printf '%q\n' ${options,,} | sed -e 's/[:=]/\\\&/g' -e "/''/d")

    # create additional completions with short root key names for convenience
    echo "$options" | sed -e 's/^hkey_local_machine/hklm/' -e \
        's/^hkey_current_user/hkcu/' -e 's/^hkey_current_config/hkcc/' -e \
        's/^hkey_users/hku/'

    # return as newline separated values
    echo "$options"

    # return root keys
    echo 'hkey_local_machine\\'
    echo 'hklm\\'
    echo 'hkey_current_user\\'
    echo 'hkcu\\'
    echo 'hkey_current_config\\'
    echo 'hkcc\\'
    echo 'hkey_users\\'
    echo 'hku\\'
    echo '/?'
}

_windows_reg_values()
{
    local options IFS

    # query for values
    options=$(reg query "$1" /f "*" /d 2> /dev/null | sed -e '1,2d' -e '$d' -e 's/^[ ]\+//' -e '/^(Default)/ d' -e 's/    REG_.*$//g' )

    # make lowercase
    # escape bash tokenizer strings and separate with newlines
    # escape bash completion word breaks that aren't otherwise escaped by "printf '%q'"
    # remove the quoted blank string that occurs if there are no values echo "${options,,}" | sed -e 's/[:=]/\\\&/g'
    IFS=$'\n'
    printf '%q\n' ${options,,} | sed -e 's/[:=]/\\\&/g' -e "/''/d"
}

# TODO: mutually exclusive options (ie. reg:32 and reg:64)
# TODO: dependent options (ie. /k /d /c /e are dependent upon /f)
# TODO: fix option culling loops for escaped characters

_windows_reg()
{
    local cur prev words cword split options cmd key IFS
    _init_completion || return

    if [[ $cword -eq 1 ]] ; then
        cmd='query add delete copy save restore load unload compare export
        import flags /?'
        COMPREPLY=( $( compgen -W '$cmd' -- "$cur" ) )
        return
    fi

    if [[ $prev == "/?" ]]; then
        return
    fi

    cmd=${words[1]}
    key=$(printf %b ${words[2]})

    case $cmd in

        query)
            if [[ $cword -eq 2 ]]; then
                _reg_keys
                return
            fi

            if [[ "$prev" == "/v" ]]; then
                _reg_values
                return
            fi

            if [[ "$prev" == "/se" || "$prev" == "/f" ]]; then
                return
            fi

            if [[ "$prev" == "/t" ]]; then
                COMPREPLY=( $(compgen -W 'reg_sz reg_multi_sz reg_expand_sz
                reg_dword reg_qword reg_binary reg_none' -- $cur ) )
                return
            fi

            # cull the list of switches if they've been used
            local option_list=( '/v' '/ve' '/s' '/f' '/k' '/d' '/c'
            '/e' '/t' '/z' '/se' '/reg\:32' '/reg\:64' )

            for option in ${option_list[@]} ; do
                local found=0

                for word in ${words[@]::$cword} ; do
                    if [[ $word == $option ]]; then
                        found=1 
                        break
                    fi
                done

                if [[ $found -eq 0 ]]; then
                    options+="$option "
                fi
            done
            ;;

        add)
            if [[ $cword -eq 2 ]]; then
                _reg_keys
                return
            fi

            if [[ "$prev" == "/v" ]]; then
                _reg_values
                return
            fi

            if [[ "$prev" == "/s" || "$prev" == "/d" ]]; then
                return
            fi

            if [[ "$prev" == "/t" ]]; then
                COMPREPLY=( $(compgen -W 'reg_sz reg_multi_sz reg_expand_sz
                reg_dword reg_qword reg_binary reg_none' -- $cur ) )
                return
            fi

            # cull the list of switches if they've been used
            local option_list=( '/v' '/ve' '/s' '/f' '/d' '/t' '/s'
            '/reg\:32' '/reg\:64' )

            for option in ${option_list[@]} ; do
                local found=0

                for word in ${words[@]::${cword}} ; do
                    if [[ $word == $option ]]; then
                        found=1 
                        break
                    fi
                done

                if [[ $found -eq 0 ]]; then
                    options+="$option "
                fi
            done
            ;;

        delete)
            if [[ $cword -eq 2 ]]; then
                _reg_keys
                return
            fi

            if [[ "$prev" == "/v" ]]; then
                _reg_values
                return
            fi

            # cull the list of switches if they've been used
            local option_list=( '/v' '/ve' '/va' '/f' '/reg\:32'
            '/reg\:64' )

            for option in ${option_list[@]} ; do
                local found=0

                for word in ${words[@]::${cword}} ; do
                    if [[ $word == $option ]]; then
                        found=1 
                        break
                    fi
                done

                if [[ $found -eq 0 ]]; then
                    options+="$option "
                fi
            done
            ;;

        copy)
            if [[ $cword -eq 3 || $cword -eq 2 ]]; then
                _reg_keys
                return
            fi

            # cull the list of switches if they've been used
            local option_list=( "/s" "/f" "/reg\:32" "/reg\:64" )

            for option in ${option_list[@]} ; do
                local found=0

                for word in ${words[@]::${cword}} ; do
                    if [[ $word == $option ]]; then
                        found=1 
                        break
                    fi
                done

                if [[ $found -eq 0 ]]; then
                    options+="$option "
                fi
            done
            ;;

        export)
            ;&

        save)
            if [[ $cword -eq 2 ]]; then
                _reg_keys
                return
            fi

            if [[ $cword -eq 3 ]]; then
                return
            fi

            # cull the list of switches if they've been used
            local option_list=( "/y" "/reg\:32" "/reg\:64" )

            for option in ${option_list[@]} ; do
                local found=0

                for word in ${words[@]::${cword}} ; do
                    if [[ $word == $option ]]; then
                        found=1 
                        break
                    fi
                done

                if [[ $found -eq 0 ]]; then
                    options+="$option "
                fi
            done
            ;;

        load)
            ;&

        restore)
            if [[ $cword -eq 2 ]]; then
                _reg_keys
                return
            fi

            if [[ $cword -eq 3 ]]; then
                return
            fi

            # cull the list of switches if they've been used
            local option_list=( "/reg\:32" "/reg\:64" )

            for option in ${option_list[@]} ; do
                local found=0

                for word in ${words[@]::${cword}} ; do
                    if [[ $word == $option ]]; then
                        found=1 
                        break
                    fi
                done

                if [[ $found -eq 0 ]]; then
                    options+="$option "
                fi
            done
            ;;

        unload)
            if [[ $cword -eq 2 ]]; then
                _reg_keys
                return
            fi
            ;;

        compare)
            if [[ $cword -eq 3 || $cword -eq 2 ]]; then
                _reg_keys
                return
            fi

            if [[ "$prev" == "/v" ]]; then
                _reg_values
                return
            fi

            # cull the list of switches if they've been used
            local option_list=( '/v' '/ve' '/s' '/oa' '/od' '/os'
            '/on' '/reg\:32' '/reg\:64' )

            for option in ${option_list[@]} ; do
                local found=0

                for word in ${words[@]::${cword}} ; do
                    if [[ $word == $option ]]; then
                        found=1 
                        break
                    fi
                done

                if [[ $found -eq 0 ]]; then
                    options+="$option "
                fi
            done

            ;;

        import)
            if [[ $cword -eq 2 ]]; then
                return
            fi

            if [[ $cword -eq 3 ]]; then
                options='/reg\:32 /reg\:64'
            fi
            ;;

        flags)
            if [[ $cword -eq 2 ]]; then
                _reg_keys
                return
            fi

            if [[ "${words[3]}" == "query" ]]; then
                return
            fi

            if [[ $cword -eq 3 ]]; then
                COMPREPLY=( $(compgen -W 'query set' -- $cur ) )
                return
            fi

            # cull the list of switches if they've been used
            local option_list=( 'dont_virtualize'
            'dont_silent_fail' 'recurse_flag' '/reg\:32' '/reg\:64')

            for option in ${option_list[@]} ; do
                local found=0

                for word in ${words[@]::$cword} ; do
                    if [[ $word == $option ]]; then
                        found=1 
                        break
                    fi
                done

                if [[ $found -eq 0 ]]; then
                    options+="$option "
                fi
            done

            ;;

    esac

    COMPREPLY=( $(compgen -W '$options' -- $cur ) )

    [[ $COMPREPLY == *\\ ]] && compopt -o nospace

    return
}

complete -o default -F _windows_reg reg reg.exe

